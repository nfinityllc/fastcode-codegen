package com.nfinity.codegen;

import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
class GitRepositoryManager {
    private static String destinationPath = null;
    private static String command = null;
    private static String GIT_VERSION_NOT_ALLOW_MERGE_UNRELATED_HISTORIES = "2.9.0";
    private static String UPGRADE_BRANCH = "upgrade_application";
    static final String GIT_TEMPLATE_FOLDER = "/templates";

    @Autowired
    CodeGeneratorUtils codeGeneratorUtils;
    
    @Autowired
    CommandUtils comamndUtils;
    
    public void setDestinationPath(String path) {
        destinationPath = path;
    }
    
    public boolean isGitInstalled() {

        command = "--version";
        String result = comamndUtils.runGitProcess(command , destinationPath);
        String regex = ".*?((?<!\\w)\\d+([.-]\\d+)*).*";
        result = result.replaceAll(regex, "$1");
        if(result == "") {
            System.out.print("\ngit is not found on your computer.");
            System.out.print("\nInstall git: \"https://git-scm.com/\"");
            return false;
        }
        return true;
    }

    public Boolean isGitInitialized() {
        command = "rev-parse -q --is-inside-work-tree";
        String commandResult = comamndUtils.runGitProcess(command, destinationPath);
        return commandResult.trim().equalsIgnoreCase("true");
    }

    public void initializeGit() {
        // Initialize directory as git repository
        command = "init";
        comamndUtils.runGitProcess(command, destinationPath);

        // Set required configuration
        command = "config --global user.name \"fastCode\"";
        comamndUtils.runGitProcess(command, destinationPath);

        command = "config --global user.email \"info@nfinityllc.com\"";
        comamndUtils.runGitProcess(command, destinationPath);
    }

    public boolean hasUncommittedChanges() {
        //get git status
        command = "status --porcelain";
        String cmdOutput = comamndUtils.runGitProcess(command, destinationPath);
        //Unable to check for local changes:
        //local changes found. Please commit/stash them before upgrading
       
        return !cmdOutput.isEmpty();
    }

    public String getCurrentBranch() {
        command = "rev-parse -q --abbrev-ref HEAD";
        String cmdOutput = comamndUtils.runGitProcess(command, destinationPath);
        //Unable to detect current Git branch
        return cmdOutput;
    }

    public Boolean createUpgradeBranch() {
        command = "rev-parse -q --verify " + UPGRADE_BRANCH;
        String commandResult = comamndUtils.runGitProcess(command, destinationPath);
        if(commandResult.isEmpty()) {
            command = "checkout --orphan " + UPGRADE_BRANCH;
            comamndUtils.runGitProcess(command, destinationPath);
            //Unable to create ${UPGRADE_BRANCH} branch:
            //Created branch ${UPGRADE_BRANCH}
        }
        return true;
    }

    public void addToGitRepository(Boolean doUpgrade, String sourceBranch) {
        if(!doUpgrade) {
            commitInitialApplication();
        }
        else {
            commitUpgradeBranch();
            command = "checkout -q " + sourceBranch;
            comamndUtils.runGitProcess(command, destinationPath);
            //Merging changes back to source branch...
            if(versionCompare(getGitVersion(),  GIT_VERSION_NOT_ALLOW_MERGE_UNRELATED_HISTORIES) == -1) {
                command = "merge --strategy=ours -q --no-edit " + UPGRADE_BRANCH;
            }
            else {
                command = "merge --allow-unrelated-histories " + UPGRADE_BRANCH;
            }
            comamndUtils.runGitProcess(command, destinationPath);
            //Check conflicts in package.json
            command = "diff --name-only --diff-filter=U package.json";
            comamndUtils.runGitProcess(command, destinationPath);
            //There are conflicts in package.json, please fix them and then run npm install command ('npm install')
            //Check conflicts during merge
            command = "diff --name-only --diff-filter=U";
            comamndUtils.runGitProcess(command, destinationPath);
            //Please fix conflicts listed below and commit!
        }
    }

    public void commitInitialApplication() {
        if(isGitInstalled() && isGitInitialized()) {
            command = "add -A";
            comamndUtils.runGitProcess(command, destinationPath);

            //TODO: Add version dynamically
            String commitMsg = "Initial application generated by fastCode-1.0";
            command = "commit -m \"" + commitMsg + "\"";
            comamndUtils.runGitProcess(command, destinationPath);
            System.out.print("Application successfully committed to Git.");
        }
        else {
            System.out.print("The generated application could not be committed to Git, as a Git repository could not be initialized.");
        }
    }

    public void commitUpgradeBranch() {
        command = "add -A";
        comamndUtils.runGitProcess(command, destinationPath);
        //Unable to add resources in git:

        //TODO: Add version dynamically
        String commitMsg = "Generated with fastCode-1.0";
        command = "commit -q -m \"" + commitMsg + "\" -a --allow-empty --no-verify";
        comamndUtils.runGitProcess(command, destinationPath);
        System.out.print("Application successfully committed to Git.");
    }

    public String getGitVersion() {
        //String(msg.match(/([0-9]+\.[0-9]+\.[0-9]+)/g))
        command = "--version";
        String cmdOutput = comamndUtils.runGitProcess(command, destinationPath);
        cmdOutput = cmdOutput.replaceAll(".*?((?<!\\w)\\d+([.-]\\d+)*).*", "$1");
        return cmdOutput;
    }
    
    public int versionCompare(String str1, String str2) {
        try (Scanner s1 = new Scanner(str1);
            Scanner s2 = new Scanner(str2);) {
            s1.useDelimiter("\\.");
            s2.useDelimiter("\\.");

            while (s1.hasNextInt() && s2.hasNextInt()) {
                int v1 = s1.nextInt();
                int v2 = s2.nextInt();
                if (v1 < v2) {
                    return -1;
                } else if (v1 > v2) {
                    return 1;
                }
            }

            if (s1.hasNextInt() && s1.nextInt() != 0)
                return 1; //str1 has an additional lower-level version number
            if (s2.hasNextInt() && s2.nextInt() != 0)
                return -1; //str2 has an additional lower-level version

            return 0;
        } // end of try-with-resources
    }

    public void CopyGitFiles() {
        Map<String, Object> root = new HashMap<>();
       codeGeneratorUtils.generateFiles(getGitTemplates(), root, destinationPath,GIT_TEMPLATE_FOLDER);
    }
    
    public Map<String, Object> getGitTemplates() {
    	
        Map<String, Object> gitTemplate = new HashMap<>();
        gitTemplate.put("gitignore.ftl", ".gitignore");
        return gitTemplate;
    }

}
